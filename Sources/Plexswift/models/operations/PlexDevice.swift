// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

import Foundation

extension Operations {
    /// A model object
    public struct PlexDevice {
        public let accessToken: String
        public let clientIdentifier: String
        public let connections: [Operations.Connections]
        @DateTime
        public private(set) var createdAt: Date
        public let device: String
        public let dnsRebindingProtection: Bool
        public let home: Bool
        public let httpsRequired: Bool
        @DateTime
        public private(set) var lastSeenAt: Date
        public let name: String
        public let natLoopbackSupported: Bool
        public let owned: Bool
        /// ownerId is null when the device is owned by the token used to send the request
        public let ownerId: Int
        public let platform: String
        public let platformVersion: String
        public let presence: Bool
        public let product: String
        public let productVersion: String
        public let provides: String
        public let publicAddress: String
        public let publicAddressMatches: Bool
        public let relay: Bool
        public let sourceTitle: String
        public let synced: Bool

        /// Creates an object with the specified parameters
        ///
        /// - Parameter ownerId: ownerId is null when the device is owned by the token used to send the request
        ///
        public init(accessToken: String, clientIdentifier: String, connections: [Operations.Connections], createdAt: Date, device: String, dnsRebindingProtection: Bool, home: Bool, httpsRequired: Bool, lastSeenAt: Date, name: String, natLoopbackSupported: Bool, owned: Bool, ownerId: Int, platform: String, platformVersion: String, presence: Bool, product: String, productVersion: String, provides: String, publicAddress: String, publicAddressMatches: Bool, relay: Bool, sourceTitle: String, synced: Bool) {
            self.accessToken = accessToken
            self.clientIdentifier = clientIdentifier
            self.connections = connections
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.device = device
            self.dnsRebindingProtection = dnsRebindingProtection
            self.home = home
            self.httpsRequired = httpsRequired
            self._lastSeenAt = DateTime<Date>(wrappedValue: lastSeenAt)
            self.name = name
            self.natLoopbackSupported = natLoopbackSupported
            self.owned = owned
            self.ownerId = ownerId
            self.platform = platform
            self.platformVersion = platformVersion
            self.presence = presence
            self.product = product
            self.productVersion = productVersion
            self.provides = provides
            self.publicAddress = publicAddress
            self.publicAddressMatches = publicAddressMatches
            self.relay = relay
            self.sourceTitle = sourceTitle
            self.synced = synced
        }
    }}

extension Operations.PlexDevice: Codable {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case clientIdentifier
        case connections
        case createdAt
        case device
        case dnsRebindingProtection
        case home
        case httpsRequired
        case lastSeenAt
        case name
        case natLoopbackSupported
        case owned
        case ownerId
        case platform
        case platformVersion
        case presence
        case product
        case productVersion
        case provides
        case publicAddress
        case publicAddressMatches
        case relay
        case sourceTitle
        case synced
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.accessToken = try container.decode(String.self, forKey: .accessToken)
        self.clientIdentifier = try container.decode(String.self, forKey: .clientIdentifier)
        self.connections = try container.decode([Operations.Connections].self, forKey: .connections)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.device = try container.decode(String.self, forKey: .device)
        self.dnsRebindingProtection = try container.decode(Bool.self, forKey: .dnsRebindingProtection)
        self.home = try container.decode(Bool.self, forKey: .home)
        self.httpsRequired = try container.decode(Bool.self, forKey: .httpsRequired)
        self._lastSeenAt = try container.decode(DateTime<Date>.self, forKey: .lastSeenAt)
        self.name = try container.decode(String.self, forKey: .name)
        self.natLoopbackSupported = try container.decode(Bool.self, forKey: .natLoopbackSupported)
        self.owned = try container.decode(Bool.self, forKey: .owned)
        self.ownerId = try container.decode(Int.self, forKey: .ownerId)
        self.platform = try container.decode(String.self, forKey: .platform)
        self.platformVersion = try container.decode(String.self, forKey: .platformVersion)
        self.presence = try container.decode(Bool.self, forKey: .presence)
        self.product = try container.decode(String.self, forKey: .product)
        self.productVersion = try container.decode(String.self, forKey: .productVersion)
        self.provides = try container.decode(String.self, forKey: .provides)
        self.publicAddress = try container.decode(String.self, forKey: .publicAddress)
        self.publicAddressMatches = try container.decode(Bool.self, forKey: .publicAddressMatches)
        self.relay = try container.decode(Bool.self, forKey: .relay)
        self.sourceTitle = try container.decode(String.self, forKey: .sourceTitle)
        self.synced = try container.decode(Bool.self, forKey: .synced)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.accessToken, forKey: .accessToken)
        try container.encode(self.clientIdentifier, forKey: .clientIdentifier)
        try container.encode(self.connections, forKey: .connections)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.device, forKey: .device)
        try container.encode(self.dnsRebindingProtection, forKey: .dnsRebindingProtection)
        try container.encode(self.home, forKey: .home)
        try container.encode(self.httpsRequired, forKey: .httpsRequired)
        try container.encode(self._lastSeenAt, forKey: .lastSeenAt)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.natLoopbackSupported, forKey: .natLoopbackSupported)
        try container.encode(self.owned, forKey: .owned)
        try container.encode(self.ownerId, forKey: .ownerId)
        try container.encode(self.platform, forKey: .platform)
        try container.encode(self.platformVersion, forKey: .platformVersion)
        try container.encode(self.presence, forKey: .presence)
        try container.encode(self.product, forKey: .product)
        try container.encode(self.productVersion, forKey: .productVersion)
        try container.encode(self.provides, forKey: .provides)
        try container.encode(self.publicAddress, forKey: .publicAddress)
        try container.encode(self.publicAddressMatches, forKey: .publicAddressMatches)
        try container.encode(self.relay, forKey: .relay)
        try container.encode(self.sourceTitle, forKey: .sourceTitle)
        try container.encode(self.synced, forKey: .synced)
    }
}

extension Operations.PlexDevice {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var lastSeenAtWrapper: DateTime<Date> {
        return _lastSeenAt
    }
}
