// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.


import Foundation

class _PlaylistsAPI: PlaylistsAPI {
    private let client: Client

    init(client: Client) {
        self.client = client
    }
    
    public func createPlaylist(request: Operations.CreatePlaylistRequest) async throws -> Response<Operations.CreatePlaylistResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureCreatePlaylistRequest(with: configuration, request: request)
            },
            handleResponse: handleCreatePlaylistResponse
        )
    }
    
    public func getPlaylists(request: Operations.GetPlaylistsRequest) async throws -> Response<Operations.GetPlaylistsResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureGetPlaylistsRequest(with: configuration, request: request)
            },
            handleResponse: handleGetPlaylistsResponse
        )
    }
    
    public func getPlaylist(request: Operations.GetPlaylistRequest) async throws -> Response<Operations.GetPlaylistResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureGetPlaylistRequest(with: configuration, request: request)
            },
            handleResponse: handleGetPlaylistResponse
        )
    }
    
    public func deletePlaylist(request: Operations.DeletePlaylistRequest) async throws -> Response<Operations.DeletePlaylistResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureDeletePlaylistRequest(with: configuration, request: request)
            },
            handleResponse: handleDeletePlaylistResponse
        )
    }
    
    public func updatePlaylist(request: Operations.UpdatePlaylistRequest) async throws -> Response<Operations.UpdatePlaylistResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureUpdatePlaylistRequest(with: configuration, request: request)
            },
            handleResponse: handleUpdatePlaylistResponse
        )
    }
    
    public func getPlaylistContents(request: Operations.GetPlaylistContentsRequest) async throws -> Response<Operations.GetPlaylistContentsResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureGetPlaylistContentsRequest(with: configuration, request: request)
            },
            handleResponse: handleGetPlaylistContentsResponse
        )
    }
    
    public func clearPlaylistContents(request: Operations.ClearPlaylistContentsRequest) async throws -> Response<Operations.ClearPlaylistContentsResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureClearPlaylistContentsRequest(with: configuration, request: request)
            },
            handleResponse: handleClearPlaylistContentsResponse
        )
    }
    
    public func addPlaylistContents(request: Operations.AddPlaylistContentsRequest) async throws -> Response<Operations.AddPlaylistContentsResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureAddPlaylistContentsRequest(with: configuration, request: request)
            },
            handleResponse: handleAddPlaylistContentsResponse
        )
    }
    
    public func uploadPlaylist(request: Operations.UploadPlaylistRequest) async throws -> Response<Operations.UploadPlaylistResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureUploadPlaylistRequest(with: configuration, request: request)
            },
            handleResponse: handleUploadPlaylistResponse
        )
    }

}

// MARK: - Request Configuration

private func configureCreatePlaylistRequest(with configuration: URLRequestConfiguration, request: Operations.CreatePlaylistRequest) throws {
    configuration.path = "/playlists"
    configuration.method = .post
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetPlaylistsRequest(with configuration: URLRequestConfiguration, request: Operations.GetPlaylistsRequest) throws {
    configuration.path = "/playlists"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetPlaylistRequest(with configuration: URLRequestConfiguration, request: Operations.GetPlaylistRequest) throws {
    configuration.path = "/playlists/{playlistID}"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureDeletePlaylistRequest(with configuration: URLRequestConfiguration, request: Operations.DeletePlaylistRequest) throws {
    configuration.path = "/playlists/{playlistID}"
    configuration.method = .delete
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureUpdatePlaylistRequest(with configuration: URLRequestConfiguration, request: Operations.UpdatePlaylistRequest) throws {
    configuration.path = "/playlists/{playlistID}"
    configuration.method = .put
    configuration.pathParameterSerializable = request
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetPlaylistContentsRequest(with configuration: URLRequestConfiguration, request: Operations.GetPlaylistContentsRequest) throws {
    configuration.path = "/playlists/{playlistID}/items"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureClearPlaylistContentsRequest(with configuration: URLRequestConfiguration, request: Operations.ClearPlaylistContentsRequest) throws {
    configuration.path = "/playlists/{playlistID}/items"
    configuration.method = .delete
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureAddPlaylistContentsRequest(with configuration: URLRequestConfiguration, request: Operations.AddPlaylistContentsRequest) throws {
    configuration.path = "/playlists/{playlistID}/items"
    configuration.method = .put
    configuration.pathParameterSerializable = request
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureUploadPlaylistRequest(with configuration: URLRequestConfiguration, request: Operations.UploadPlaylistRequest) throws {
    configuration.path = "/playlists/upload"
    configuration.method = .post
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

// MARK: - Response Handlers

private func handleCreatePlaylistResponse(response: Client.APIResponse) throws -> Operations.CreatePlaylistResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .twoHundredApplicationJsonObject(try JSONDecoder().decode(Operations.CreatePlaylistResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndOneApplicationJsonObject(try JSONDecoder().decode(Operations.CreatePlaylistPlaylistsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetPlaylistsResponse(response: Client.APIResponse) throws -> Operations.GetPlaylistsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .twoHundredApplicationJsonObject(try JSONDecoder().decode(Operations.GetPlaylistsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndOneApplicationJsonObject(try JSONDecoder().decode(Operations.GetPlaylistsPlaylistsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetPlaylistResponse(response: Client.APIResponse) throws -> Operations.GetPlaylistResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .twoHundredApplicationJsonObject(try JSONDecoder().decode(Operations.GetPlaylistResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndOneApplicationJsonObject(try JSONDecoder().decode(Operations.GetPlaylistPlaylistsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleDeletePlaylistResponse(response: Client.APIResponse) throws -> Operations.DeletePlaylistResponse {
    let httpResponse = response.httpResponse
    
    if [204, 400].contains(httpResponse.statusCode) { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .object(try JSONDecoder().decode(Operations.DeletePlaylistResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleUpdatePlaylistResponse(response: Client.APIResponse) throws -> Operations.UpdatePlaylistResponse {
    let httpResponse = response.httpResponse
    
    if [200, 400].contains(httpResponse.statusCode) { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .object(try JSONDecoder().decode(Operations.UpdatePlaylistResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetPlaylistContentsResponse(response: Client.APIResponse) throws -> Operations.GetPlaylistContentsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .twoHundredApplicationJsonObject(try JSONDecoder().decode(Operations.GetPlaylistContentsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndOneApplicationJsonObject(try JSONDecoder().decode(Operations.GetPlaylistContentsPlaylistsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleClearPlaylistContentsResponse(response: Client.APIResponse) throws -> Operations.ClearPlaylistContentsResponse {
    let httpResponse = response.httpResponse
    
    if [200, 400].contains(httpResponse.statusCode) { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .object(try JSONDecoder().decode(Operations.ClearPlaylistContentsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleAddPlaylistContentsResponse(response: Client.APIResponse) throws -> Operations.AddPlaylistContentsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .twoHundredApplicationJsonObject(try JSONDecoder().decode(Operations.AddPlaylistContentsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndOneApplicationJsonObject(try JSONDecoder().decode(Operations.AddPlaylistContentsPlaylistsResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleUploadPlaylistResponse(response: Client.APIResponse) throws -> Operations.UploadPlaylistResponse {
    let httpResponse = response.httpResponse
    
    if [200, 400].contains(httpResponse.statusCode) { 
        return .empty
    } else if httpResponse.statusCode == 401 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .object(try JSONDecoder().decode(Operations.UploadPlaylistResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

