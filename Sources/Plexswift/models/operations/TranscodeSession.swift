// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

import Foundation

extension Operations {
    /// A model object
    public struct TranscodeSession {
        public let audioChannels: Int?
        public let audioCodec: String?
        public let audioDecision: String?
        public let complete: Bool?
        public let container: String?
        public let context: String?
        public let duration: Int?
        public let error: Bool?
        public let key: String?
        @DecimalSerialized
        public private(set) var maxOffsetAvailable: Double?
        @DecimalSerialized
        public private(set) var minOffsetAvailable: Double?
        @DecimalSerialized
        public private(set) var progress: Double?
        public let `protocol`: String?
        public let remaining: Int?
        public let size: Int?
        public let sourceAudioCodec: String?
        public let sourceVideoCodec: String?
        @DecimalSerialized
        public private(set) var speed: Double?
        public let subtitleDecision: String?
        public let throttled: Bool?
        @DecimalSerialized
        public private(set) var timeStamp: Double?
        public let transcodeHwRequested: Bool?
        public let videoCodec: String?
        public let videoDecision: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(audioChannels: Int? = nil, audioCodec: String? = nil, audioDecision: String? = nil, complete: Bool? = nil, container: String? = nil, context: String? = nil, duration: Int? = nil, error: Bool? = nil, key: String? = nil, maxOffsetAvailable: Double? = nil, minOffsetAvailable: Double? = nil, progress: Double? = nil, `protocol`: String? = nil, remaining: Int? = nil, size: Int? = nil, sourceAudioCodec: String? = nil, sourceVideoCodec: String? = nil, speed: Double? = nil, subtitleDecision: String? = nil, throttled: Bool? = nil, timeStamp: Double? = nil, transcodeHwRequested: Bool? = nil, videoCodec: String? = nil, videoDecision: String? = nil) {
            self.audioChannels = audioChannels
            self.audioCodec = audioCodec
            self.audioDecision = audioDecision
            self.complete = complete
            self.container = container
            self.context = context
            self.duration = duration
            self.error = error
            self.key = key
            self._maxOffsetAvailable = DecimalSerialized<Double?>(wrappedValue: maxOffsetAvailable)
            self._minOffsetAvailable = DecimalSerialized<Double?>(wrappedValue: minOffsetAvailable)
            self._progress = DecimalSerialized<Double?>(wrappedValue: progress)
            self.`protocol` = `protocol`
            self.remaining = remaining
            self.size = size
            self.sourceAudioCodec = sourceAudioCodec
            self.sourceVideoCodec = sourceVideoCodec
            self._speed = DecimalSerialized<Double?>(wrappedValue: speed)
            self.subtitleDecision = subtitleDecision
            self.throttled = throttled
            self._timeStamp = DecimalSerialized<Double?>(wrappedValue: timeStamp)
            self.transcodeHwRequested = transcodeHwRequested
            self.videoCodec = videoCodec
            self.videoDecision = videoDecision
        }
    }}

extension Operations.TranscodeSession: Codable {
    enum CodingKeys: String, CodingKey {
        case audioChannels
        case audioCodec
        case audioDecision
        case complete
        case container
        case context
        case duration
        case error
        case key
        case maxOffsetAvailable
        case minOffsetAvailable
        case progress
        case `protocol` = "protocol"
        case remaining
        case size
        case sourceAudioCodec
        case sourceVideoCodec
        case speed
        case subtitleDecision
        case throttled
        case timeStamp
        case transcodeHwRequested
        case videoCodec
        case videoDecision
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.audioChannels = try container.decodeIfPresent(Int.self, forKey: .audioChannels)
        self.audioCodec = try container.decodeIfPresent(String.self, forKey: .audioCodec)
        self.audioDecision = try container.decodeIfPresent(String.self, forKey: .audioDecision)
        self.complete = try container.decodeIfPresent(Bool.self, forKey: .complete)
        self.container = try container.decodeIfPresent(String.self, forKey: .container)
        self.context = try container.decodeIfPresent(String.self, forKey: .context)
        self.duration = try container.decodeIfPresent(Int.self, forKey: .duration)
        self.error = try container.decodeIfPresent(Bool.self, forKey: .error)
        self.key = try container.decodeIfPresent(String.self, forKey: .key)
        self._maxOffsetAvailable = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .maxOffsetAvailable) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._minOffsetAvailable = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .minOffsetAvailable) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._progress = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .progress) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.`protocol` = try container.decodeIfPresent(String.self, forKey: .`protocol`)
        self.remaining = try container.decodeIfPresent(Int.self, forKey: .remaining)
        self.size = try container.decodeIfPresent(Int.self, forKey: .size)
        self.sourceAudioCodec = try container.decodeIfPresent(String.self, forKey: .sourceAudioCodec)
        self.sourceVideoCodec = try container.decodeIfPresent(String.self, forKey: .sourceVideoCodec)
        self._speed = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .speed) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.subtitleDecision = try container.decodeIfPresent(String.self, forKey: .subtitleDecision)
        self.throttled = try container.decodeIfPresent(Bool.self, forKey: .throttled)
        self._timeStamp = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .timeStamp) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.transcodeHwRequested = try container.decodeIfPresent(Bool.self, forKey: .transcodeHwRequested)
        self.videoCodec = try container.decodeIfPresent(String.self, forKey: .videoCodec)
        self.videoDecision = try container.decodeIfPresent(String.self, forKey: .videoDecision)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(self.audioChannels, forKey: .audioChannels)
        try container.encodeIfPresent(self.audioCodec, forKey: .audioCodec)
        try container.encodeIfPresent(self.audioDecision, forKey: .audioDecision)
        try container.encodeIfPresent(self.complete, forKey: .complete)
        try container.encodeIfPresent(self.container, forKey: .container)
        try container.encodeIfPresent(self.context, forKey: .context)
        try container.encodeIfPresent(self.duration, forKey: .duration)
        try container.encodeIfPresent(self.error, forKey: .error)
        try container.encodeIfPresent(self.key, forKey: .key)
        if self.maxOffsetAvailable != nil {
            try container.encode(self._maxOffsetAvailable, forKey: .maxOffsetAvailable)
        }
        if self.minOffsetAvailable != nil {
            try container.encode(self._minOffsetAvailable, forKey: .minOffsetAvailable)
        }
        if self.progress != nil {
            try container.encode(self._progress, forKey: .progress)
        }
        try container.encodeIfPresent(self.`protocol`, forKey: .`protocol`)
        try container.encodeIfPresent(self.remaining, forKey: .remaining)
        try container.encodeIfPresent(self.size, forKey: .size)
        try container.encodeIfPresent(self.sourceAudioCodec, forKey: .sourceAudioCodec)
        try container.encodeIfPresent(self.sourceVideoCodec, forKey: .sourceVideoCodec)
        if self.speed != nil {
            try container.encode(self._speed, forKey: .speed)
        }
        try container.encodeIfPresent(self.subtitleDecision, forKey: .subtitleDecision)
        try container.encodeIfPresent(self.throttled, forKey: .throttled)
        if self.timeStamp != nil {
            try container.encode(self._timeStamp, forKey: .timeStamp)
        }
        try container.encodeIfPresent(self.transcodeHwRequested, forKey: .transcodeHwRequested)
        try container.encodeIfPresent(self.videoCodec, forKey: .videoCodec)
        try container.encodeIfPresent(self.videoDecision, forKey: .videoDecision)
    }
}

extension Operations.TranscodeSession {
    var progressWrapper: DecimalSerialized<Double?> {
        return _progress
    }
    var speedWrapper: DecimalSerialized<Double?> {
        return _speed
    }
    var timeStampWrapper: DecimalSerialized<Double?> {
        return _timeStamp
    }
    var maxOffsetAvailableWrapper: DecimalSerialized<Double?> {
        return _maxOffsetAvailable
    }
    var minOffsetAvailableWrapper: DecimalSerialized<Double?> {
        return _minOffsetAvailable
    }
}
