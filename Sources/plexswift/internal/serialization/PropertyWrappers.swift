// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

// MARK: - Wrappers

/// An internal type used to aid in serializing request data and deserializing response data.
///
/// > Important: This type should not be used directly.
@propertyWrapper public struct DecimalSerialized<Value>: Codable, Serializable where Value: DoubleConvertible {
    // This property wrapper ensures that we (de)serialize values as Decimals to avoid floating-point rounding errors.

    public var wrappedValue: Value

    public init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        wrappedValue = try Value.decodeValue(with: container)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let double = wrappedValue.toDouble() {
            try container.encode(Decimal(double))
        }
    }

    // MARK: - Serializable

    func serialize(with format: SerializableFormat) throws -> String {
        return wrappedValue.toDouble().map { String($0) } ?? ""
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension DecimalSerialized: CustomStringConvertible where Value: CustomStringConvertible {
    public var description: String {
        return wrappedValue.description
    }
}

/// An internal type used to aid in serializing request data and deserializing response data.
///
/// > Important: This type should not be used directly.
@propertyWrapper public struct DateTime<Value>: Codable, Serializable where Value: DateConvertible {
    // This property wrapper ensures that we (de)serialize Swift Dates in the correct datetime format.

    public var wrappedValue: Value

    public init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        wrappedValue = try Value.decodeValue(with: container, formatter: dateTimeFormatter)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let formatted = wrappedValue.formattedString(with: dateTimeFormatter) {
            try container.encode(formatted)
        }
    }

    // MARK: - Serializable

    func serialize(with format: SerializableFormat) throws -> String {
        return wrappedValue.formattedString(with: dateTimeFormatter) ?? ""
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension DateTime: CustomStringConvertible where Value: CustomStringConvertible {
    public var description: String {
        return wrappedValue.description
    }
}

/// An internal type used to aid in serializing request data and deserializing response data.
///
/// > Important: This type should not be used directly.
@propertyWrapper public struct DateOnly<Value>: Codable, Serializable where Value: DateConvertible {
    // This property wrapper ensures that we (de)serialize dates in the date-only format, as Date doesn't distinguish between these types.

    public var wrappedValue: Value

    public init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        wrappedValue = try Value.decodeValue(with: container, formatter: dateOnlyFormatter)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let formatted = wrappedValue.formattedString(with: dateOnlyFormatter) {
            try container.encode(formatted)
        }
    }

    // MARK: - Serializable

    func serialize(with format: SerializableFormat) throws -> String {
        return wrappedValue.formattedString(with: dateOnlyFormatter) ?? ""
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension DateOnly: CustomStringConvertible where Value: CustomStringConvertible {
    public var description: String {
        return wrappedValue.description
    }
}

// MARK: - Formatters

private let dateTimeFormatter = {
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
    return dateFormatter
}()

private let dateOnlyFormatter = {
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter
}()

// MARK: - Helpers

/// An internal type used to aid in serializing request data.
///
/// > Important: This type should not be used directly.
public protocol DoubleConvertible {
    func toDouble() -> Double?
    static func decodeValue(with container: SingleValueDecodingContainer) throws -> Self
}

extension Double: DoubleConvertible {
    public static func decodeValue(with container: SingleValueDecodingContainer) throws -> Double {
        return try container.decode(Double.self)
    }

    public func toDouble() -> Double? {
        return self
    }
}

extension Optional: DoubleConvertible where Wrapped == Double {
    public static func decodeValue(with container: SingleValueDecodingContainer) throws -> Optional<Double> {
        if container.decodeNil() {
            return nil
        } else {
            return try container.decode(Double.self)
        }
    }

    public func toDouble() -> Double? {
        return self
    }
}

/// An internal type used to aid in serializing request data.
///
/// > Important: This type should not be used directly.
public protocol DateConvertible {
    func toDate() -> Date?
    func formattedString(with formatter: DateFormatter) -> String?

    static func decodeValue(with container: SingleValueDecodingContainer, formatter: DateFormatter) throws -> Self
}

extension Date: DateConvertible {
    public static func decodeValue(with container: SingleValueDecodingContainer, formatter: DateFormatter) throws -> Date {
        let string = try container.decode(String.self)
        guard let date = formatter.date(from: string) else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Invalid date string value '\(string)'"
            )
        }
        return date
    }

    public func toDate() -> Date? {
        return self
    }

    public func formattedString(with formatter: DateFormatter) -> String? {
        return formatter.string(from: self)
    }
}

extension Optional: DateConvertible where Wrapped == Date {
    public static func decodeValue(with container: SingleValueDecodingContainer, formatter: DateFormatter) throws -> Optional<Date> {
        if container.decodeNil() {
            return nil
        } else {
            let string = try container.decode(String.self)
            guard let date = formatter.date(from: string) else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Invalid date string value '\(string)'"
                )
            }
            return date
        }
    }

    public func toDate() -> Date? {
        return self
    }

    public func formattedString(with formatter: DateFormatter) -> String? {
        return self.map { formatter.string(from: $0) }
    }
}
