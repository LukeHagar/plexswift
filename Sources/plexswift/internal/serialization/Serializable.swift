// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

enum QueryParameterSerializableStyle {
    case form
    case pipeDelimited
    case deepObject
}

enum SerializableFormat {
    case path(explode: Bool)
    case query(style: QueryParameterSerializableStyle, explode: Bool)
    case header(explode: Bool)
    case multipart
    case form(explode: Bool)

    var explode: Bool {
        switch self {
        case .path(let explode), .query(_, let explode), .header(let explode), .form(let explode):
            return explode
        case .multipart:
            return false
        }
    }

    var isDeep: Bool {
        switch self {
        case .path, .header, .multipart, .form:
            return false
        case .query(let style, _):
            switch style {
            case .form, .pipeDelimited:
                return false
            case .deepObject:
                return true
            }
        }
    }
}

struct QueryParameter {
    let key: [String]
    let serialized: String
    let index: Int

    init(key: [String], serialized: String) {
        self.key = key
        self.serialized = serialized
        self.index = 0
    }

    init(key: [String], serialized: String, index: Int) {
        self.key = key
        self.serialized = serialized
        self.index = index
    }
}

enum SerializationError: Swift.Error {
    case failedToSerializeData
    case missingRequiredRequestBody
    case invalidSerializationParameter(type: String, format: String)
}

protocol Serializable {
    func serialize(with format: SerializableFormat) throws -> String
    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter]
}

extension Serializable {
    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return []
    }
}

// MARK: - Primitives

extension NSNull: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        return "null"
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension String: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        return self
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension Int: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        return String(self)
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension Double: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        return String(self)
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension Bool: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        return String(self)
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension Data: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        guard let string = String(data: self, encoding: .ascii) else {
            throw SerializationError.failedToSerializeData
        }
        return string
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return [QueryParameter(key: [], serialized: try serialize(with: format))]
    }
}

extension Optional: Serializable where Wrapped: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        return try self?.serialize(with: format) ?? ""
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        return try self?.serializeQueryParameters(with: format) ?? []
    }
}

// MARK: - Collections

extension Array: Serializable where Element: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
      return try map { try $0.serialize(with: format) }.joined(separator: format.separator)
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        if format.explode {
            return try enumerated().map { index, value in
                QueryParameter(key: [], serialized: try value.serialize(with: format), index: index)
            }
        } else {
            return [QueryParameter(key: [], serialized: try serialize(with: format))]
        }
    }
}

extension Dictionary: Serializable where Key == String, Value: Serializable {
    func serialize(with format: SerializableFormat) throws -> String {
        // Sort by keys first to make serialization deterministic.
        return try map { key, value in
            (key, value)
        }.sorted {
            $0.0 < $1.0
        }.map { (key, value) in
            if format.explode {
                return "\(key)=\(try value.serialize(with: format))"
            } else {
                return "\(key)\(format.separator)\(try value.serialize(with: format))"
            }
        }.joined(separator: format.separator)
    }

    func serializeQueryParameters(with format: SerializableFormat) throws -> [QueryParameter] {
        if format.explode {
            return try flatMap { key, value in
                try value.serializeQueryParameters(with: format).mapKeys { _ in [key] }
            }
        } else {
            return [QueryParameter(key: [], serialized: try serialize(with: format))]
        }
    }
}

// MARK: - Extensions

extension SerializableFormat {
  var separator: String {
    switch self {
    case .path, .header, .multipart, .form:
      return ","
    case .query(let style, _):
      switch style {
      case .form, .deepObject:
        return ","
      case .pipeDelimited:
        return "|"
      }
    }
  }
}
